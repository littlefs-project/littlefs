# simple formatting test
[cases.format]
code = '''
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;
'''

# mount/unmount
[cases.mount]
code = '''
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;
    lfs_mount(&lfs, cfg) => 0;
    lfs_unmount(&lfs) => 0;
'''

# reentrant format
[cases.reentrant_format]
reentrant = true
code = '''
    lfs_t lfs;
    int err = lfs_mount(&lfs, cfg);
    if (err) {
        lfs_format(&lfs, cfg) => 0;
        lfs_mount(&lfs, cfg) => 0;
    }
    lfs_unmount(&lfs) => 0;
'''

# invalid mount
[cases.invalid_mount]
code = '''
    lfs_t lfs;
    lfs_mount(&lfs, cfg) => LFS_ERR_CORRUPT;
'''

# expanding superblock
[cases.expanding_superblock]
defines.LFS_BLOCK_CYCLES = [32, 33, 1]
defines.N = [10, 100, 1000]
code = '''
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;
    lfs_mount(&lfs, cfg) => 0;
    for (int i = 0; i < N; i++) {
        lfs_file_t file;
        lfs_file_open(&lfs, &file, "dummy",
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        lfs_file_close(&lfs, &file) => 0;
        struct lfs_info info;
        lfs_stat(&lfs, "dummy", &info) => 0;
        assert(strcmp(info.name, "dummy") == 0);
        assert(info.type == LFS_TYPE_REG);
        lfs_remove(&lfs, "dummy") => 0;
    }
    lfs_unmount(&lfs) => 0;

    // one last check after power-cycle
    lfs_mount(&lfs, cfg) => 0;
    lfs_file_t file;
    lfs_file_open(&lfs, &file, "dummy",
            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
    lfs_file_close(&lfs, &file) => 0;
    struct lfs_info info;
    lfs_stat(&lfs, "dummy", &info) => 0;
    assert(strcmp(info.name, "dummy") == 0);
    assert(info.type == LFS_TYPE_REG);
    lfs_unmount(&lfs) => 0;
'''

# expanding superblock with power cycle
[cases.expanding_superblock_power_cycle]
defines.LFS_BLOCK_CYCLES = [32, 33, 1]
defines.N = [10, 100, 1000]
code = '''
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;
    for (int i = 0; i < N; i++) {
        lfs_mount(&lfs, cfg) => 0;
        // remove lingering dummy?
        struct lfs_info info;
        int err = lfs_stat(&lfs, "dummy", &info);
        assert(err == 0 || (err == LFS_ERR_NOENT && i == 0));
        if (!err) {
            assert(strcmp(info.name, "dummy") == 0);
            assert(info.type == LFS_TYPE_REG);
            lfs_remove(&lfs, "dummy") => 0;
        }

        lfs_file_t file;
        lfs_file_open(&lfs, &file, "dummy",
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        lfs_file_close(&lfs, &file) => 0;
        lfs_stat(&lfs, "dummy", &info) => 0;
        assert(strcmp(info.name, "dummy") == 0);
        assert(info.type == LFS_TYPE_REG);
        lfs_unmount(&lfs) => 0;
    }

    // one last check after power-cycle
    lfs_mount(&lfs, cfg) => 0;
    struct lfs_info info;
    lfs_stat(&lfs, "dummy", &info) => 0;
    assert(strcmp(info.name, "dummy") == 0);
    assert(info.type == LFS_TYPE_REG);
    lfs_unmount(&lfs) => 0;
'''

# reentrant expanding superblock
[cases.reentrant_expanding_superblock]
defines.LFS_BLOCK_CYCLES = [2, 1]
defines.N = 24
reentrant = true
code = '''
    lfs_t lfs;
    int err = lfs_mount(&lfs, cfg);
    if (err) {
        lfs_format(&lfs, cfg) => 0;
        lfs_mount(&lfs, cfg) => 0;
    }

    for (int i = 0; i < N; i++) {
        // remove lingering dummy?
        struct lfs_info info;
        err = lfs_stat(&lfs, "dummy", &info);
        assert(err == 0 || (err == LFS_ERR_NOENT && i == 0));
        if (!err) {
            assert(strcmp(info.name, "dummy") == 0);
            assert(info.type == LFS_TYPE_REG);
            lfs_remove(&lfs, "dummy") => 0;
        }

        lfs_file_t file;
        lfs_file_open(&lfs, &file, "dummy",
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        lfs_file_close(&lfs, &file) => 0;
        lfs_stat(&lfs, "dummy", &info) => 0;
        assert(strcmp(info.name, "dummy") == 0);
        assert(info.type == LFS_TYPE_REG);
    }

    lfs_unmount(&lfs) => 0;

    // one last check after power-cycle
    lfs_mount(&lfs, cfg) => 0;
    struct lfs_info info;
    lfs_stat(&lfs, "dummy", &info) => 0;
    assert(strcmp(info.name, "dummy") == 0);
    assert(info.type == LFS_TYPE_REG);
    lfs_unmount(&lfs) => 0;
'''
