[cases.recursive_remove]
defines.N = [1, 3, 10, 100]
defines.M = [1, 3, 10, 100]
if = 'M * N < BLOCK_COUNT/2'
code = '''
    lfs_t lfs;
    char path[1024];
    int i, j;
    lfs_format(&lfs, cfg) => 0;
    lfs_mount(&lfs, cfg) => 0;
    lfs_ssize_t fs_size = lfs_fs_size(&lfs);
    lfs_mkdir(&lfs, "prickly-pear") => 0;
    srand(1);

    for (i = 0; i < N; i++) {
        sprintf(path, "prickly-pear/cactus%03d", i);
        lfs_mkdir(&lfs, path) => 0;
    }

    // For the first 5 directories, insert child files
    for (i = 0; i < 5 && i < N; i++) {
        lfs_file_t file;
        for (j = 0; j < M; j++) {
            sprintf(path, "prickly-pear/cactus%03d/%03d", i, j);
            lfs_file_open(&lfs, &file, path,
                    LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
            lfs_file_truncate(&lfs, &file, 512) => 0;
            lfs_file_close(&lfs, &file) => 0;
        }
    }

    lfs_dir_t dir;
    struct lfs_info info;
    lfs_dir_open(&lfs, &dir, "prickly-pear") => 0;
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);
    for (i = 0; i < N; i++) {
        sprintf(path, "cactus%03d", i);
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_DIR);
        assert(strcmp(info.name, path) == 0);
    }
    lfs_dir_read(&lfs, &dir, &info) => 0;
    lfs_dir_close(&lfs, &dir) => 0;
    lfs_unmount(&lfs);

    lfs_mount(&lfs, cfg) => 0;
    lfs_remove(&lfs, "prickly-pear") => LFS_ERR_NOTEMPTY;
    lfs_remove_recursive(&lfs, "prickly-pear") => 0;

    lfs_fs_size(&lfs) => fs_size;

    lfs_remove(&lfs, "prickly-pear/cactus001") => LFS_ERR_NOENT;

    lfs_remove(&lfs, "prickly-pear") => LFS_ERR_NOENT;
    lfs_unmount(&lfs) => 0;


    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_size(&lfs) => fs_size;
    lfs_remove(&lfs, "prickly-pear") => LFS_ERR_NOENT;
    lfs_unmount(&lfs) => 0;
'''
